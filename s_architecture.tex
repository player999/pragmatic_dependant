\section{System Architecture}
First, lets get familiar with mathematical fundamentals of proposed solution. They were proposed by A. Matlsev\cite{maltsevalgebra} and then enhanced by V. Redko\cite{redko}. The point is that every program is function. The function maps input to output, one memory region to another. Next statement that function may be decomposed on simplier parts, compositions of basic operations, to be computable by specific computer. Together with carrier set (datatype, which processed), the set of operations and compositions forms algebraic structure. This algebraic structure formed depending on pragmatics of problem given. Here compositions are operations over set of operations and other compositions. Due to usage of algebraic structures, we are able to design mathematically correct hardware and programms. Because they designed on correct basis. Now consider programming language, it is based on a limited set opeartions, which were proposed by programming language developers, who, in the most cases, did not substantiated the selection.

Lets have a closer look at design process in action. First, designer considers pragmatic aspect of the given problem and selects the most adquate set of operations and compositions, substantiating it. The next step is to write down semantics of the solution. For today only man can produce semantics, it is complicated and too creative work for machine. It may only assist designer on this step. So the solution is written as the designer understands it, not as computer understands.

If the set of opeartions in designer's solution is different to one that chosen. So the solution must be rewritten in the chosen set of operations and compositions. If some operations are not in the set of chosen opertions,but they were perviously implemented on selected algebraic structure, the next step begins. If not, the designer implements them for the algebraic structure selected. 

Now user can automatically produce syntax of the solution for specific platform. The system teakes as input semantic representation of the solution, then resolves unresolved operations and compositions. After resolving, it converts the solution to a platform specific syntax. In which the algebraic structure was implemented, for example, HDL. Later this algebric structure may be supplemented with other operations and compositions.

